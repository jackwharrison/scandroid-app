<!DOCTYPE html>
<html lang="{{ lang }}" {% if lang == 'ar' %}dir="rtl"{% endif %}>
<head>
  <meta charset="UTF-8" />
  <title>{{ t.title or "Beneficiary Information" }}</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <link rel="manifest" href="/manifest.webmanifest">
  <meta name="theme-color" content="#ffffff">

  <style>
    :root { --pad: 16px; --gap: 12px; --radius: 16px; --card: #fff; --ink: #111; --muted:#6b7280; --line:#e5e7eb; --bg:#f3f4f6; }
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); }
    .wrap { max-width: 840px; margin: 0 auto; padding: 24px; }
    .card { background: var(--card); border-radius: 18px; box-shadow: 0 10px 30px rgba(0,0,0,.06); border: 1px solid var(--line); overflow: hidden; }
    .header { padding: 18px var(--pad); border-bottom: 1px solid var(--line); display: grid; gap: 10px; align-items: center; grid-template-columns: 1fr; text-align: center; }
    .logos { display: flex; gap: 16px; justify-content: center; align-items: center; flex-wrap: wrap; }
    .logos img { height: 42px; }
    h1 { font-size: 28px; margin: 8px 0 0; }
    .section { padding: 18px var(--pad); }
    .photo-wrap { display: grid; place-items: center; gap: 8px; padding: 8px 0 0; }
    .photo { width: 220px; height: 220px; border-radius: 12px; background: #f0f3f7; border: 1px dashed #cdd6e1; display: grid; place-items: center; color: #6b7280; font-size: 14px; text-align: center; padding: 8px; }
    .photo img { width: 220px; height: 220px; object-fit: cover; border-radius: 12px; display: none; }
    .badge { font-size: 12px; color: var(--muted); }
    .fields { display: grid; gap: 10px; }
    .row { display: grid; grid-template-columns: 200px 1fr; gap: 12px; }
    .label { color: var(--muted); }
    .value { font-weight: 600; word-break: break-word; }
    .note { font-size: 12px; color: var(--muted); }
    .actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px; }
    .btn { padding: 12px 14px; border-radius: 12px; border: 1px solid var(--line); background: #f9fafb; cursor: pointer; font-weight: 700; }
    .btn-approve { background: #e8f9ef; border-color: #bfe9cf; }
    .btn-reject  { background: #fdecec; border-color: #f7c5c5; }
    .key-badge { font-size: 12px; color: #047857; background:#d1fae5; border:1px solid #a7f3d0; padding:4px 8px; border-radius:999px; display:inline-block; }
    @media (max-width: 640px) { .row { grid-template-columns: 1fr; } .logos img { height: 36px; } h1 { font-size: 24px; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div class="logos">
          <img src="{{ url_for('static', filename='ns1.png') }}" alt="NS1">
          <img src="{{ url_for('static', filename='scandroid_banner.png') }}" alt="Scandroid">
          <img src="{{ url_for('static', filename='ns2.png') }}" alt="NS2">
        </div>
        <h1>{{ t.title or "Beneficiary Information" }}</h1>
        <div id="keyStatus" class="key-badge" style="display:none;">Decryption enabled</div>
      </div>

      <div class="section">
        {% if photo_config and photo_config.enabled %}
        <div class="photo-wrap">
          <div style="font-weight:700; margin-bottom:4px;">{{ photo_config.labels[lang] if photo_config.labels else "Photo" }}</div>
          <div class="photo">
            <img id="photo" alt="Photo">
            <div id="photoMsg">Loading photo‚Ä¶</div>
          </div>
          <div class="badge" id="photoBadge"></div>
        </div>
        {% endif %}
      </div>

      <div class="section">
        <div class="fields" id="fields"></div>
      </div>

      <div class="section">
        <div class="actions">
          <button class="btn btn-approve" id="approveBtn">{{ t.payment_approved or "Payment Approved" }}</button>
          <button class="btn btn-reject"  id="rejectBtn">{{ t.payment_rejected or "Payment Rejected" }}</button>
        </div>
        <div class="note" id="decisionNote" style="margin-top:8px;"></div>
      </div>
    </div>
  </div>

  <script>
    /* ---------- Fernet decrypt (WebCrypto) ---------- */
    const b64u = {
      toBytes: (s) => {
        s = s.replace(/-/g, '+').replace(/_/g, '/');
        while (s.length % 4) s += '=';
        const bin = atob(s);
        const out = new Uint8Array(bin.length);
        for (let i=0;i<bin.length;i++) out[i] = bin.charCodeAt(i);
        return out;
      },
      fromBytes: (b) => {
        let s = '';
        for (let i=0;i<b.length;i++) s += String.fromCharCode(b[i]);
        return btoa(s).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
      }
    };
    function looksEncrypted(val) {
      if (typeof val !== 'string') return false;
      if (!val || val.length < 40) return false;
      return val.startsWith('gAAAAA') || /^[A-Za-z0-9_-]{40,}$/.test(val);
    }
    async function importHmacKey(raw) {
      return crypto.subtle.importKey('raw', raw, { name: 'HMAC', hash: 'SHA-256' }, false, ['verify']);
    }
    async function importAesKey(raw) {
      return crypto.subtle.importKey('raw', raw, { name: 'AES-CBC' }, false, ['decrypt']);
    }
    function concat(...arrs) {
      let len=0; for (const a of arrs) len+=a.length;
      const out = new Uint8Array(len);
      let o=0; for (const a of arrs) { out.set(a,o); o+=a.length; }
      return out;
    }
    async function fernetDecryptToBytes(token, keyB64) {
      const key = b64u.toBytes(keyB64);
      if (key.length !== 32) throw new Error('Key must be 32 bytes');
      const signing = key.slice(0,16);
      const encrypt = key.slice(16,32);

      const raw = b64u.toBytes(token);
      if (raw.length < 1+8+16+32) throw new Error('Token too short');
      const version = raw[0]; if (version !== 0x80) throw new Error('Bad version');

      const ts = raw.slice(1, 9);
      const iv = raw.slice(9, 25);
      const mac = raw.slice(raw.length - 32);
      const ct  = raw.slice(25, raw.length - 32);

      const msg = concat(new Uint8Array([version]), ts, iv, ct);
      const hmacKey = await importHmacKey(signing);
      const ok = await crypto.subtle.verify('HMAC', hmacKey, mac, msg);
      if (!ok) throw new Error('HMAC failed');

      const aesKey = await importAesKey(encrypt);
      const pt = new Uint8Array(await crypto.subtle.decrypt({ name:'AES-CBC', iv }, aesKey, ct));
      return pt;
    }
    async function fernetDecryptString(token, keyB64, dec = new TextDecoder()) {
      const bytes = await fernetDecryptToBytes(token, keyB64);
      return dec.decode(bytes);
    }
    async function fernetDecryptBlob(blobOrBytes, keyB64) {
      const encBytes = blobOrBytes instanceof Blob
        ? new Uint8Array(await blobOrBytes.arrayBuffer())
        : (blobOrBytes instanceof Uint8Array ? blobOrBytes : new Uint8Array(blobOrBytes || []));
      const tokenB64u = b64u.fromBytes(encBytes);
      const plain = await fernetDecryptToBytes(tokenB64u, keyB64);
      return new Blob([plain], { type: 'image/jpeg' });
    }

    /* ---------- IndexedDB ---------- */
    const DB_NAME = 'scandroid';
    const DB_VER  = 2;
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VER);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains('records')) db.createObjectStore('records', { keyPath: 'uuid' });
          if (!db.objectStoreNames.contains('photos'))  db.createObjectStore('photos',  { keyPath: 'uuid' });
          if (!db.objectStoreNames.contains('meta'))    db.createObjectStore('meta',    { keyPath: 'key' });
          if (!db.objectStoreNames.contains('decisions')) db.createObjectStore('decisions', { keyPath: 'uuid' });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror   = () => reject(req.error);
      });
    }
    function dbGet(db, store, key) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(store, 'readonly');
        const st = tx.objectStore(store);
        const rq = st.get(key);
        rq.onsuccess = () => resolve(rq.result || null);
        rq.onerror   = () => reject(rq.error);
      });
    }
    function dbPut(db, store, value) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction(store, 'readwrite');
        const st = tx.objectStore(store);
        const rq = st.put(value);
        rq.onsuccess = () => resolve(true);
        rq.onerror   = () => reject(rq.error);
      });
    }
    function dbFindRecordByAnyId(db, needle) {
      return new Promise((resolve, reject) => {
        const tx = db.transaction('records', 'readonly');
        const st = tx.objectStore('records');
        const req = st.openCursor();
        let found = null;
        req.onsuccess = (e) => {
          const cursor = e.target.result;
          if (!cursor) return resolve(found);
          const rec = cursor.value; const d = rec && rec.data || {};
          const n = String(needle);
          const match =
            String(rec.uuid || '') === n ||
            String(rec.registrationId || '') === n ||
            String(d._id || '') === n ||
            String(d._uuid || '') === n;
          if (match) { found = rec; return resolve(found); }
          cursor.continue();
        };
        req.onerror = () => reject(req.error);
      });
    }

    /* ---------- Template inputs ---------- */
    const LANG = "{{ lang }}";
    const UUID_FROM_SERVER = "{{ uuid or '' }}";
    const URL_UUID = new URLSearchParams(location.search).get('uuid') || "";
    const SCANNED_ID = URL_UUID || UUID_FROM_SERVER;

    const fieldsConfig = {{ display_fields|tojson }};
    const photoEnabled = {{ (photo_config and photo_config.enabled)|tojson }};
    const SERVER_FERNET_KEY = "{{ fernet_key or '' }}"; // <- provided by Flask from system config

    /* ---------- UI ---------- */
    function renderFields(container, data, keyB64) {
      container.innerHTML = "";
      const rows = Array.isArray(fieldsConfig) ? fieldsConfig : [];
      for (const f of rows) {
        const fieldKey = f.key || f.name || f.field;
        const label = (f.labels && (f.labels[LANG] || f.labels.en)) || fieldKey || "";
        if (!fieldKey) continue;

        const hasValue = data && Object.prototype.hasOwnProperty.call(data, fieldKey);
        const raw = hasValue ? data[fieldKey] : "";

        const row = document.createElement('div');
        row.className = 'row';

        const lab = document.createElement('div');
        lab.className = 'label';
        lab.textContent = label;

        const v = document.createElement('div');
        v.className = 'value';

        (async () => {
          try {
            if (!hasValue || raw === "" || raw == null) {
              v.innerHTML = `<span class="note">(value not available offline)</span>`;
            } else if (looksEncrypted(String(raw))) {
              if (!keyB64) {
                v.innerHTML = `<span class="note">(encrypted ‚Äî decryption key not set)</span>`;
              } else {
                const txt = await fernetDecryptString(String(raw), keyB64);
                v.textContent = txt;
              }
            } else {
              v.textContent = String(raw);
            }
          } catch {
            v.innerHTML = `<span class="note">(decryption failed)</span>`;
          }
        })();

        row.appendChild(lab);
        row.appendChild(v);
        container.appendChild(row);
      }
    }

    async function loadPage() {
      const fieldsEl = document.getElementById('fields');
      const photoMsg = document.getElementById('photoMsg');
      const photoBadge = document.getElementById('photoBadge');
      const imgEl = document.getElementById('photo');
      const keyBadge = document.getElementById('keyStatus');

      // Show badge if we have a key from config
      const keyB64 = SERVER_FERNET_KEY && SERVER_FERNET_KEY.length ? SERVER_FERNET_KEY : "";
      if (keyB64) keyBadge.style.display = 'inline-block';

      if (!SCANNED_ID) {
        fieldsEl.innerHTML = `<div class="note">No ID provided. Opened offline shell page.</div>`;
        if (photoMsg) photoMsg.textContent = 'Photo unavailable (no ID).';
        return;
      }

      let db;
      try { db = await openDB(); }
      catch { fieldsEl.innerHTML = `<div class="note">IndexedDB unavailable.</div>`; return; }

      // Find record by uuid / _id / registrationId
      let rec = await dbGet(db, 'records', String(SCANNED_ID));
      if (!rec) {
        const idx = await dbGet(db, 'meta', 'idIndex');
        const map = idx && idx.value || {};
        const n = String(SCANNED_ID);
        const mappedUuid = map['uuid:' + n] || map['kobo:' + n] || map['reg:' + n] || null;
        if (mappedUuid) rec = await dbGet(db, 'records', mappedUuid);
      }
      if (!rec) rec = await dbFindRecordByAnyId(db, SCANNED_ID);

      if (!rec) {
        fieldsEl.innerHTML = `<div class="note">No offline record found for this beneficiary.</div>`;
        if (photoMsg) photoMsg.textContent = 'No photo found in cache.';
        return;
      }

      // Decrypt & render fields
      renderFields(fieldsEl, rec.data || {}, keyB64);

      // Photos
// Photos (try token-string first, then raw-bytes fallback)
if (photoEnabled) {
  try {
    const p = await dbGet(db, 'photos', rec.uuid);
    if (p && (p.bytes || p.blob)) {
      if (!keyB64) {
        if (photoBadge) photoBadge.textContent = 'üì¶ Encrypted photo cached on device';
        if (photoMsg)  photoMsg.textContent  = 'Encrypted ‚Äî decryption key not set';
      } else {
        let decryptedBlob = null;

        // 1) Try treating stored data as a Fernet TOKEN STRING
        try {
          let tokenText;
          if (p.blob && typeof p.blob.text === 'function') {
            tokenText = await p.blob.text();
          } else if (p.bytes) {
            // attempt to decode bytes as UTF-8 token text
            tokenText = new TextDecoder().decode(
              p.bytes instanceof Uint8Array ? p.bytes : new Uint8Array(p.bytes)
            );
          }
          if (tokenText && tokenText.length > 40) {
            const plainBytes = await fernetDecryptToBytes(tokenText.trim(), keyB64);
            decryptedBlob = new Blob([plainBytes], { type: 'image/jpeg' });
          } else {
            throw new Error('Not a token string');
          }
        } catch (e1) {
          console.warn('Photo: token-string decrypt failed, trying raw bytes‚Ä¶', e1);

          // 2) Fallback: treat stored data as raw encrypted bytes (Fernet)
          const enc = p.blob
            ? new Uint8Array(await p.blob.arrayBuffer())
            : (p.bytes instanceof Uint8Array ? p.bytes : new Uint8Array(p.bytes || []));
          decryptedBlob = await fernetDecryptBlob(enc, keyB64);
        }

        // Show photo
        imgEl.src = URL.createObjectURL(decryptedBlob);
        imgEl.style.display = 'block';
        if (photoMsg) photoMsg.textContent = '';
        if (photoBadge) photoBadge.textContent = '';
      }
    } else {
      if (photoMsg) photoMsg.textContent = 'No photo found in cache.';
    }
  } catch (e) {
    console.warn('Photo decrypt/display error:', e);
    if (photoMsg) photoMsg.textContent = 'Photo decryption failed.';
  }
}
async function handleDecision(status) {
  try {
    const db = await openDB();
    const rec = await dbFindRecordByAnyId(db, SCANNED_ID);
    if (!rec) {
      alert("No record found.");
      return;
    }

    const configRes = await fetch("/system-config.json");
    const config = await configRes.json();
    const columnKey = config.COLUMN_TO_MATCH || "phoneNumber";
    const matchValue = rec.data?.[columnKey] || "";

    const decision = {
      uuid: rec.uuid,
      status: status,
      columnKey: columnKey,
      matchValue: matchValue,
      timestamp: new Date().toISOString()
    };

    console.log("Saving decision to IndexedDB:", decision);

    await dbPut(db, 'decisions', decision);

    window.location.href = `/success-offline?lang=${encodeURIComponent(LANG)}`;
  } catch (err) {
    console.error("Failed to save decision:", err);
    alert("Failed to save decision.");
  }
}



  const note = document.getElementById('decisionNote');
  const redirectToSuccess = () => {
    const url = `/success-offline?lang=${encodeURIComponent(LANG)}`;
    window.location.href = url;
  };

async function savePaymentDecision(decisionValue) {
  try {
    console.log("üü° Starting to save decision:", decisionValue);

    const db = await openDB();

    console.log("üü¢ DB opened:", db);

    if (!db.objectStoreNames.contains('payments')) {
      console.warn("‚ö†Ô∏è 'payments' store missing, trying to create it...");

      db.close();
      const upgradeReq = indexedDB.open(DB_NAME, DB_VER + 1);

      upgradeReq.onupgradeneeded = () => {
        const upgradedDB = upgradeReq.result;
        if (!upgradedDB.objectStoreNames.contains('payments')) {
          upgradedDB.createObjectStore('payments', { keyPath: 'uuid' });
        }
        console.log("‚úÖ payments store created.");
      };

      upgradeReq.onsuccess = () => {
        console.log("‚úÖ Upgrade success");
        upgradeReq.result.close();
        note.textContent = '‚ö†Ô∏è Please reload the page to complete database update.';
      };

      upgradeReq.onerror = (event) => {
        console.error("‚ùå Upgrade error:", event.target.error);
        note.textContent = '‚ö†Ô∏è Error updating database structure.';
        alert("‚ö†Ô∏è Upgrade failed: " + event.target.error.message);
      };
      return;
    }

    const columnToMatch = 'registrationId';
    const columnValue = rec[columnToMatch] || rec.data?.[columnToMatch] || '';

    console.log("üì¶ Preparing to store:", {
      uuid: rec.uuid,
      decision: decisionValue,
      timestamp: Date.now(),
      column_to_match: columnToMatch,
      column_value: columnValue
    });

    const tx = db.transaction('payments', 'readwrite');
    const store = tx.objectStore('payments');

    const decisionData = {
      uuid: rec.uuid,
      decision: decisionValue,
      timestamp: Date.now(),
      column_to_match: columnToMatch,
      column_value: columnValue
    };

    const request = store.put(decisionData);

    request.onsuccess = () => {
      console.log("‚úÖ Data saved to IndexedDB.");
    };

    request.onerror = (event) => {
      console.error("‚ùå Store put error:", event.target.error);
      alert("‚ùå Store put failed: " + event.target.error.message);
    };

    tx.oncomplete = () => {
      console.log("‚úÖ Transaction complete.");
      note.textContent = `‚úÖ Saved locally: Payment ${decisionValue}`;
      setTimeout(redirectToSuccess, 600);
    };

    tx.onerror = (event) => {
      console.error("‚ùå Transaction error:", event.target.error);
      note.textContent = '‚ùå Failed to save decision locally.';
      alert('‚ùå Transaction failed: ' + event.target.error.message);
    };

  } catch (err) {
    console.error("‚ùå Unexpected error saving decision:", err);
    note.textContent = '‚ùå Unexpected error. Cannot save decision.';
    alert("‚ùå Unexpected error:\n" + (err.message || JSON.stringify(err)));
  }
}


document.getElementById("approveBtn").addEventListener("click", () => handleDecision("approved"));
document.getElementById("rejectBtn").addEventListener("click", () => handleDecision("rejected"));


    }

    document.addEventListener('DOMContentLoaded', loadPage);
  </script>

<script>
  const APP_VERSION = "4";  // ‚Üê bump this to match version.json

  async function checkAppVersion() {
    try {
      const res = await fetch("/version.json", { cache: "no-store" });
      if (!res.ok) return;
      const data = await res.json();
      const latest = data.version;
      if (latest && latest !== APP_VERSION) {
        if (confirm("‚ö†Ô∏è A new version is available.\nClick OK to refresh and update.")) {
          location.reload(true);
        }
      }
    } catch (e) {
      console.warn("Version check failed", e);
    }
  }

  checkAppVersion();
</script>
</body>
</html>
